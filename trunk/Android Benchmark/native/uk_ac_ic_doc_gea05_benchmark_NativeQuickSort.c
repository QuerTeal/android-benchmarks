/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class uk_ac_ic_doc_gea05_benchmark_QuickSort */

#ifndef _Included_uk_ac_ic_doc_gea05_benchmark_QuickSort
#define _Included_uk_ac_ic_doc_gea05_benchmark_QuickSort
#ifdef __cplusplus
extern "C" {
#endif
#undef uk_ac_ic_doc_gea05_benchmark_QuickSort_CUTOFF
#define uk_ac_ic_doc_gea05_benchmark_QuickSort_CUTOFF 10L

//median of 3 quick sort.


const int CUTOFF = 10;
//median of 3 quick sort.

/**
 * Method to swap to elements in an array.
 * @param a an array of objects.
 * @param index1 the index of the first object.
 * @param index2 the index of the second object.
 */
int swap;
void swapReferences(int a[], int index1, int index2) {
	swap = a[index1];
	a[index1] = a[index2];
	a[index2] = swap;
}

/**
 * Internal insertion sort routine for subarrays
 * that is used by quicksort.
 * @param a an array of int items.
 * @param low the left-most index of the subarray.
 * @param n the number of items to sort.
 */
int k, p, tmp;
void insertionSort(int a[], int low, int high) {
	for (p = low + 1; p <= high; p++) {
		tmp = a[p];

		for (k = p; k > low && tmp < a[k - 1]; k--)
			a[k] = a[k - 1];
		a[k] = tmp;
	}
}

/**
 * Internal quicksort method that makes recursive calls.
 * Uses median-of-three partitioning and a cutoff of 10.
 * @param a an array of int items.
 * @param low the left-most index of the subarray.
 * @param high the right-most index of the subarray.
 */
int middle, pivot, i, j;
void quicksort(int a[], int low, int high) {
	if (low + CUTOFF > high)
		insertionSort(a, low, high);
	else {
		// Sort low, middle, high
		middle = (low + high) / 2;
		if (a[middle] < a[low])
			swapReferences(a, low, middle);
		if (a[high] < a[low])
			swapReferences(a, low, high);
		if (a[high] < a[middle])
			swapReferences(a, middle, high);

		// Place pivot at position high - 1
		swapReferences(a, middle, high - 1);
		pivot = a[high - 1];

		// Begin partitioning
		for (i = low, j = high - 1;;) {
			while (a[++i] < pivot)
				;
			while (pivot < a[--j])
				;
			if (i >= j)
				break;
			swapReferences(a, i, j);
		}

		// Restore pivot
		swapReferences(a, i, high - 1);

		quicksort(a, low, i - 1); // Sort small elements
		quicksort(a, i + 1, high); // Sort large elements
	}
}

/*
 * Class:     uk_ac_ic_doc_gea05_benchmark_QuickSort
 * Method:    nQuicksort
 * Signature: ([III)V
 */
JNIEXPORT void JNICALL Java_uk_ac_ic_doc_gea05_benchmark_NativeQuickSort_nQuicksort(
		JNIEnv *env, jclass c, jintArray jInput) {
	// Copy the arrays into main memory
	jint* cInput = (*env)->GetIntArrayElements(env, jInput, 0);
	jsize length = (*env)->GetArrayLength(env, jInput);

	quicksort(cInput, 0, length - 1);

	(*env)->SetIntArrayRegion(env, jInput, 0, length, cInput);
	(*env)->ReleaseIntArrayElements(env, jInput, cInput, 0);
}

#ifdef __cplusplus
}
#endif
#endif
